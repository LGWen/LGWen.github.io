<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="baidu-site-verification" content="1EB8XoOl0C"><meta name="google-site-verification" content="K7thEgdLm0UfRWJ5MGdF7sCcjClSzAlxFLPv2Oz5CGM"><title> 手把手教你部署NUXT项目 · 小妹要去哪~</title><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="description" content="手把手教你部署NUXT项目 - Tokas"><meta name="keywords"><meta name="author" content="Tokas"><link rel="short icon" href="/images/favicon.ico"><link rel="stylesheet" href="/css/bubuzou.css"><link rel="search" type="application/opensearchdescription+xml" href="https://lgwen.github.io/atom.xml" title="小妹要去哪~"></head><body><header><div class="header row"> <a href="/" class="logo-link"><img src="/images/logo.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" data-hover="博文" class="nav-list-link">博文</a></li><li class="nav-list-item"><a href="/archives/" target="_self" data-hover="归档" class="nav-list-link">归档</a></li><li class="nav-list-item"><a href="/about/" target="_self" data-hover="关于" class="nav-list-link">关于</a></li></ul><div class="search"><a id="search_btn" href="#search"></a></div></div></header><div class="row scroll-con"><section class="container"><!-- for archive page--><div id="postAr" class="post"><article class="post-block"><h1 class="post-title">手把手教你部署NUXT项目</h1><div class="post-info">2018-07-17<p class="visit"><i data-hk-page="current">-</i><span>次访问</span></p></div><div class="post-content"><p>下载好脚手架后我们在开发模式下直接使用 <code>npm run dev</code>即可观看、调试我们的项目页面。</p>
<p>项目完毕就准备部署预发布走测试流程。</p>
<p><a href="https://zh.nuxtjs.org" target="_blank" rel="noopener">nuxt</a>的部署可以分为两种,一种是静态应用（站点）部署，一种动态应用部署（服务端渲染应用部署）。<a href="https://zh.nuxtjs.org/guide/commands" target="_blank" rel="noopener">可以参考这里</a></p>
<h1 id="静态应用部署"><a href="#静态应用部署" class="headerlink" title="静态应用部署"></a>静态应用部署</h1><p>静态部署没什么好说的，和hexo一样，写好了内容，执行一下<code>nuxt generate</code><br>然后把根目录下生成的dist文件丢在服务器下即可。<br><a id="more"></a><br>可利用下面的命令生成应用的静态目录和文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run generate</span><br></pre></td></tr></table></figure></p>
<p>这个命令会创建一个 dist 文件夹，所有静态化后的资源文件均在其中。</p>
<h1 id="服务端渲染应用（动态）部署"><a href="#服务端渲染应用（动态）部署" class="headerlink" title="服务端渲染应用（动态）部署"></a>服务端渲染应用（动态）部署</h1><p>部署 Nuxt.js 服务端渲染的应用不能直接使用 nuxt 命令，而应该先进行编译构建，然后再启动 Nuxt 服务，可通过以下两个命令来完成：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nuxt build</span><br><span class="line">nuxt start</span><br></pre></td></tr></table></figure>
<p>但是这个命令不能再远端使用,所以我们一般把这个命令放在package.json里通过npm进行执行。</p>
<p>推荐的 package.json 配置如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"my-app"</span>,</span><br><span class="line">  <span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"nuxt"</span>: <span class="string">"latest"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"nuxt"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"nuxt build"</span>,</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"nuxt start"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>呐，官方的介绍就这么多，很简单吧，很容易吧。</p>
<p>但是你发现，这样起的服务，使用的是你本地的ip和端口。也就是你在本地开发的时候使用什么端口，这里启动的就是什么端口。我们需要的是，在本地启动的时候，使用本地ip和端口。在生产环境启动的时候就是用环境的ip和端口<br>那么我们就需要到<code>server/index.js</code>这里改一下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const host = process.env.HOST || <span class="string">'0.0.0.0'</span></span><br><span class="line">const port = process.env.PORT || 8090</span><br></pre></td></tr></table></figure>
<p>好了，这样你启动的项目就是你环境的ip端口了。</p>
<p>但是，当你关闭远端的窗口后你会发现你的项目被kill了。就像你在本地开发的时候一样，使用<code>npm run dev</code>启动服务后，按一下Ctrl + C项目就会被kill。</p>
<p>所以我们需要一个守护我们这个进程的东西，就算我离开了远端或者本地开发的时候不小心在控制台按下Ctrl + C，项目还是能正常。</p>
<p>上网查了一下守护进程的工具有很多，因为公司使用的是<a href="http://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/" target="_blank" rel="noopener">pm2</a>，使用我这里就只针对<a href="http://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/" target="_blank" rel="noopener">pm2</a>进行部署。<br>还是简单的举例一下<a href="http://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/" target="_blank" rel="noopener">pm2</a>的优势吧！</p>
<div class="tip"><br><p>1、内建负载均衡（使用Node cluster 集群模块）</p><br><br><p>2、守护进程，后台运行。<br></p><p>3、0秒停机重载，我理解大概意思是维护升级的时候不需要停机.</p><br><p>4、具有Ubuntu和CentOS 的启动脚本</p><br><p>5、停止不稳定的进程（避免无限循环）</p><br><p>6、控制台检测</p><br><p>7、提供 HTTP API</p><br><p>8、远程控制和实时的接口API ( Nodejs 模块,允许和PM2进程管理器交互 )</p><br><p>9、简洁明了的可视化窗口和调试信息。</p><br></div>

<p>上面都是网上找的优点，在使用过程中我只有明显使用到1、2、3、6、9这几个而已。</p>
<p>1、负载均衡。你完全可以使用Node cluster建立自己的子线程，同时开启多个进程来监听同一个端口，分发http请求处理。但是都有pm2帮你做了你何必又自己做呢？所以对于node的Node cluster作为了解即可啦。</p>
<p>2、守护进程，上面已经说了离开了远端项目还是能正常使用。我们一般启动的时候，pm2会默认根据机器具有几核，智能的给你开启多核。除非你自己手动限制开启。pm2 start xxx.js -i 就能启动你需要的server服务，然后-i 指定多开数量,默认为自动根据机器配置开启。</p>
<p>3、0秒停机重载。这个是不是和负载均衡有点异曲同工？</p>
<h1 id="pm2配置"><a href="#pm2配置" class="headerlink" title="pm2配置"></a>pm2配置</h1><h3 id="生成脚本"><a href="#生成脚本" class="headerlink" title="生成脚本"></a>生成脚本</h3><p>就像webpack的webpack.config.js和npm包管理的package.json一样。<br>pm2的配置脚本也是需要的，我们可以在终端pm2 ecosystem</p>
<p>会在工程下面生成一个ecosystem.config.js。（当然你可以手动新建一个该文件）</p>
<h3 id="修改脚本"><a href="#修改脚本" class="headerlink" title="修改脚本"></a>修改脚本</h3><p>根据项目简简单单的编写一下脚本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"apps"</span>: [&#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"my-app"</span>,</span><br><span class="line">        <span class="string">"max_memory_restart"</span>: <span class="string">"300M"</span>,</span><br><span class="line">        <span class="string">"script"</span>: <span class="string">"./build/main.js"</span>,</span><br><span class="line">        <span class="string">"out_file"</span>: <span class="string">"/home/efun/logs/my-app-logs/my-app-out.log"</span>,</span><br><span class="line">        <span class="string">"error_file"</span>: <span class="string">"/home/efun/logs/my-app-logs/my-app-error.log"</span>,</span><br><span class="line">        <span class="string">"merge_logs"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"instances"</span>: 2,</span><br><span class="line">        <span class="string">"exec_mode"</span>: <span class="string">"cluster"</span>,</span><br><span class="line">        <span class="string">"env"</span>: &#123;</span><br><span class="line">            <span class="string">"NODE_ENV"</span>: <span class="string">"development"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"env_production"</span>: &#123;</span><br><span class="line">            <span class="string">"NODE_ENV"</span>: <span class="string">"production"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，你要是想进行更为复杂的操作你可以企业看官网;<a href="http://pm2.keymetrics.io/docs/usage/quick-start/" target="_blank" rel="noopener">呐，地址都给你了</a></p>
<p>配置好了脚本怎么使用？</p>
<p>如果你不需要使用npm命令启动，你完全可以使用pm2的命令启动。后面跟你项目的入口js文件。<br>pm2 start xxx.js</p>
<h3 id="使用脚本启动项目"><a href="#使用脚本启动项目" class="headerlink" title="使用脚本启动项目"></a>使用脚本启动项目</h3><p>当然，启动nuxt（说白了,使用node作为前端服务器，都应该使用这种启动方法），结合package.json的script脚本进行操作。</p>
<p>下面是package.json可以作为参考</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">      <span class="string">"dev"</span>: <span class="string">"backpack dev"</span>,</span><br><span class="line">      <span class="string">"build"</span>: <span class="string">"nuxt build &amp;&amp; backpack build"</span>,</span><br><span class="line">      <span class="string">"start"</span>: <span class="string">"cross-env NODE_ENV=production node build/main.js"</span>,</span><br><span class="line">      <span class="string">"precommit"</span>: <span class="string">"npm run lint"</span>,</span><br><span class="line">      <span class="string">"lint"</span>: <span class="string">"eslint --ext .js,.vue --ignore-path .gitignore ."</span>,</span><br><span class="line">      <span class="string">"prod"</span>: <span class="string">"PORT=34004 pm2 start ecosystem.json --env production"</span>,</span><br><span class="line">      <span class="string">"pre-prod"</span>: <span class="string">"PORT=34104 pm2 start ecosystem-test.json --env production"</span>,</span><br><span class="line">      <span class="string">"pre-restart"</span>: <span class="string">"pm2 restart my-app"</span>,</span><br><span class="line">      <span class="string">"prod-restart"</span>: <span class="string">"pm2 restart my-app"</span>,</span><br><span class="line">      <span class="string">"pre-stop"</span>: <span class="string">"pm2 delete my-app"</span>,</span><br><span class="line">      <span class="string">"prod-stop"</span>: <span class="string">"pm2 delete my-app"</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>
<p>启动预发布环境就执行 npm run pre-prod启动项目，执行的是ecosystem-test.json，通过PORT把端口传过去进行区分预发布和正式环境。<br>启动预正式环境就执行 npm run prod启动项目，执行的是ecosystem.json。</p>
<p>查看程序运行：<br>[efun@Nodejskr75 pf-kr-pre]$ pm2 list<br>┌──────────────────┬────┬─────────┬───────┬────────┬─────────┬────────┬─────┬───────────┬──────┬──────────┐<br>│ App name         │ id │ mode    │ pid   │ status │ restart │ uptime │ cpu │ mem       │ user │ watching │<br>├──────────────────┼────┼─────────┼───────┼────────┼─────────┼────────┼─────┼───────────┼──────┼──────────┤<br>│ my-app           │ 51 │ cluster │ 4859  │ online │ 6       │ 2h     │ 0%  │ 87.7 MB   │ efun │ disabled │<br>│ my-app           │ 52 │ cluster │ 4864  │ online │ 6       │ 2h     │ 0%  │ 98.3 MB   │ efun │ disabled │<br>└──────────────────┴────┴─────────┴───────┴────────┴─────────┴────────┴─────┴───────────┴──────┴──────────┘</p>
<p>停用运行的程序<br>pm2 stop my-app</p>
<p>[efun@Nodejskr75 pf-kr-pre]$ pm2 stop my-app<br>[PM2] Applying action stopProcessId on app <a href="ids: 51,52" target="_blank" rel="noopener">my-app</a><br>[PM2] <a href="51">pf-kq-pre</a> ✓<br>[PM2] <a href="52">pf-kq-pre</a> ✓<br>┌──────────────────┬────┬─────────┬───────┬─────────┬─────────┬────────┬─────┬───────────┬──────┬──────────┐<br>│ App name         │ id │ mode    │ pid   │ status  │ restart │ uptime │ cpu │ mem       │ user │ watching │<br>├──────────────────┼────┼─────────┼───────┼─────────┼─────────┼────────┼─────┼───────────┼──────┼──────────┤<br>│ my-app           │ 51 │ cluster │ 0     │ stopped │ 6       │ 0      │ 0%  │ 0 B       │ efun │ disabled │<br>│ my-app           │ 52 │ cluster │ 0     │ stopped │ 6       │ 0      │ 0%  │ 0 B       │ efun │ disabled │<br>└──────────────────┴────┴─────────┴───────┴─────── ─┴─────────┴────────┴─────┴───────────┴──────┴──────────┘</p>
<p>停用后想重启程序，可以使用pm2命令reload。 pm2 reload my-app<br>也可以使用npm命令 npm run pre-restart (实际上还是执行pm2 reload my-app)</p>
<p>stop并不能清理程序，也不会释放端口，而是要delete：</p>
<p>[azuo1228@Server Meanjs-MMM]$ pm2 delete my-app<br>[PM2] Applying action deleteProcessId on app <a href="ids: 0,1" target="_blank" rel="noopener">all</a><br>[PM2] <a href="1">server</a> ✓<br>[PM2] <a href="0">server</a> ✓<br>┌──────────┬────┬──────┬─────┬────────┬─────────┬────────┬─────┬─────┬──────────┐<br>│ App name │ id │ mode │ pid │ status │ restart │ uptime │ cpu │ mem │ watching │<br>└──────────┴────┴──────┴─────┴────────┴─────────┴────────┴─────┴─────┴──────────┘<br> Use <code>pm2 show &lt;id|name&gt;</code> to get more details about an app</p>
<p>好咯，说了一堆pm2。下面说说使用pm2部署遇到的几个坑点。</p>
<p>#坑一：<br>部署到线上，需要执行<code>npm run build</code>编译成静态文件（同时压缩js、css等） 。</p>
<p>或者按照文档说的执行 <code>nuxt build</code>,这样项目才读取的才是硬盘里的文件。这一点和使用vue-cli脚手架部署一样。</p>
<p>有次就是忘记执行了，导致访问页面路由一直在loading，但是就是不出来内容，或者出来个502.<br>这里最好就一起写在npm命令的脚本里，以免下次又漏了。</p>
<p>因为公司是使用jenkins进行自动化部署，所以我这个build是放在jenkins进行操作的。</p>
<p>所以在提交git后，使用compile命令进行编译，rsync进行同步，restart进行重启，stop进行停用，start进行启动。</p>
<p>因为并不是所有公司都使用jenkins发布，所以这里就不多说。不过jenkins真的好处多多，好用又方便。</p>
<p>#坑二：</p>
<p>一个域名被解析到一个静态服务器，上面有很多静态html等各种资源(域名根目录未被使用)。后来需要加一个平台上去，同时这个平台使用该域名(根目录映射平台首页)。</p>
<p>这个时候，就需要运维同事的配合了。在处理前端访问url的时候，先经过Nginx的应用层，然后Nginx先判断改url是否带有静态资源特征，也就是.js .css .jpg .png ….。根据不同的资源路径或者路由进行分发指向node服务器还是原有的静态服务器。</p>
<p>这里上个Nginx的过滤规则：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~* ^.+.(jpg|jpeg|gif|css|png|js|ico|txt|srt|swf)$ &#123;</span><br><span class="line">    root /var/www/mywebsite/site/;</span><br><span class="line">    expires 30d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在nuxt部署后。</p>
<p>首页路由为：<a href="http://www.mywebsite.com" target="_blank" rel="noopener">www.mywebsite.com</a> ,页面依赖的其中一个js路径为<a href="https://www.mywebsite.com/_nuxt/manifest.e6cf8cf6462faca1a03e.js" target="_blank" rel="noopener">https://www.mywebsite.com/_nuxt/manifest.e6cf8cf6462faca1a03e.js</a></p>
<p>这个时候，页面上所有的js引用都是404</p>
<p>原因是因为运维同事的过滤规则导致页面读取js静态资源，跑到静态服务器上面找去了。当然找不到。因为这个js文件我们部署build的时候，是在node服务器上的。</p>
<p>这个时候需要在Nginx的过滤规则上加多权重更高的一个过滤。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~^/_nuxt/ &#123;</span><br><span class="line">	<span class="built_in">alias</span> /mywebsite/.nuxt/dist/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面是Nginx具有中间应用层的情况下的规则。那如果不需要应用层Nginx规则则为如下：</p>
<pre><code class="bash">location /_nuxt/ {
    <span class="built_in">alias</span> /var/www/mywebsite/.nuxt/dist/;
}

location ~* ^.+.(jpg|jpeg|gif|css|png|js|ico|txt|srt|swf|woff|woff2)$ {
    rewrite    ^/_nuxt(/.*) <span class="variable">$1</span> <span class="built_in">break</span>;
    root /var/www/mywebsite/.nuxt/dist;
    expires 30d;
}
</code></pre>
<p>这个在nuxt的issue地址有这个<a href="https://github.com/nuxt/nuxt.js/issues/2795" target="_blank" rel="noopener">提问</a></p>
<p>暂时说这么多，下次想到有补充再补充一下。</p>
<p>下一篇应该就是整理webpack的单页面和多页面的配置了。</p>
</div></article></div><div class="right-container"><div class="widget"><div class="category"><h4>分类归档</h4></div></div><div class="widget"><div class="tagcloud"><h4>标签云</h4></div></div><div class="widget"><div class="recent"><h4>最近文章</h4><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/07/17/nuxt-deploy/">手把手教你部署NUXT项目</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/07/17/vue-watch-objeck/">Vue中响应式检测数组、对象的属性变化（增加或者删除）</a></li></ul></div></div><div class="widget"><div id="arAnchorBar"></div></div></div></section></div><div class="right-menu"></div><div class="modal search-modal"><div class="input-field"><input type="text" id="search_input"><label for="search-input">搜索</label></div><div id="search_result" class="search-result"></div></div><div class="blog-overlay"></div><footer class="row"><div class="footer-con"><div class="paginator"><a href="/2018/07/17/vue-watch-objeck/" class="next">NEXT</a></div><div class="copyright"><p>© 2018 <a href="https://lgwen.github.io" target="_blank">Tokas</a> </p><p>powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <br> and <a href="https://github.com/Bulandent/hexo-theme-bubuzou" target="_blank">hexo-theme-bubuzou</a></p></div><div class="totop"><i></i></div></div></footer><script async src="//cdn.bootcss.com/mathjax/2.6.1/MathJax.js?config=TeX-MML-AM_CHTML"></script><script src="https://cdn.bootcss.com/jquery/1.8.3/jquery.min.js"></script><script src="https://cdn1.lncld.net/static/js/av-mini-0.6.10.js"></script><script src="/scripts/hit-kounter-lc-0.2.0.js"></script><script src="/scripts/arAnchor.js"></script><script src="/scripts/main.js"></script></body></html>