<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>手把手教你部署NUXT项目</title>
      <link href="/2018/07/17/nuxt-deploy/"/>
      <url>/2018/07/17/nuxt-deploy/</url>
      <content type="html"><![CDATA[<p>下载好脚手架后我们在开发模式下直接使用 <code>npm run dev</code>即可观看、调试我们的项目页面。</p><p>项目完毕就准备部署预发布走测试流程。</p><p><a href="https://zh.nuxtjs.org" target="_blank" rel="noopener">nuxt</a>的部署可以分为两种,一种是静态应用（站点）部署，一种动态应用部署（服务端渲染应用部署）。<a href="https://zh.nuxtjs.org/guide/commands" target="_blank" rel="noopener">可以参考这里</a></p><h1 id="静态应用部署"><a href="#静态应用部署" class="headerlink" title="静态应用部署"></a>静态应用部署</h1><p>静态部署没什么好说的，和hexo一样，写好了内容，执行一下<code>nuxt generate</code><br>然后把根目录下生成的dist文件丢在服务器下即可。<br><a id="more"></a><br>可利用下面的命令生成应用的静态目录和文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run generate</span><br></pre></td></tr></table></figure></p><p>这个命令会创建一个 dist 文件夹，所有静态化后的资源文件均在其中。</p><h1 id="服务端渲染应用（动态）部署"><a href="#服务端渲染应用（动态）部署" class="headerlink" title="服务端渲染应用（动态）部署"></a>服务端渲染应用（动态）部署</h1><p>部署 Nuxt.js 服务端渲染的应用不能直接使用 nuxt 命令，而应该先进行编译构建，然后再启动 Nuxt 服务，可通过以下两个命令来完成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nuxt build</span><br><span class="line">nuxt start</span><br></pre></td></tr></table></figure><p>但是这个命令不能再远端使用,所以我们一般把这个命令放在package.json里通过npm进行执行。</p><p>推荐的 package.json 配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"my-app"</span>,</span><br><span class="line">  <span class="string">"dependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"nuxt"</span>: <span class="string">"latest"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"dev"</span>: <span class="string">"nuxt"</span>,</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"nuxt build"</span>,</span><br><span class="line">    <span class="string">"start"</span>: <span class="string">"nuxt start"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>呐，官方的介绍就这么多，很简单吧，很容易吧。</p><p>但是你发现，这样起的服务，使用的是你本地的ip和端口。也就是你在本地开发的时候使用什么端口，这里启动的就是什么端口。我们需要的是，在本地启动的时候，使用本地ip和端口。在生产环境启动的时候就是用环境的ip和端口<br>那么我们就需要到<code>server/index.js</code>这里改一下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">const host = process.env.HOST || <span class="string">'0.0.0.0'</span></span><br><span class="line">const port = process.env.PORT || 8090</span><br></pre></td></tr></table></figure><p>好了，这样你启动的项目就是你环境的ip端口了。</p><p>但是，当你关闭远端的窗口后你会发现你的项目被kill了。就像你在本地开发的时候一样，使用<code>npm run dev</code>启动服务后，按一下Ctrl + C项目就会被kill。</p><p>所以我们需要一个守护我们这个进程的东西，就算我离开了远端或者本地开发的时候不小心在控制台按下Ctrl + C，项目还是能正常。</p><p>上网查了一下守护进程的工具有很多，因为公司使用的是<a href="http://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/" target="_blank" rel="noopener">pm2</a>，使用我这里就只针对<a href="http://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/" target="_blank" rel="noopener">pm2</a>进行部署。<br>还是简单的举例一下<a href="http://pm2.keymetrics.io/docs/usage/pm2-doc-single-page/" target="_blank" rel="noopener">pm2</a>的优势吧！</p><div class="tip"><br><p>1、内建负载均衡（使用Node cluster 集群模块）</p><br><br><p>2、守护进程，后台运行。<br></p><p>3、0秒停机重载，我理解大概意思是维护升级的时候不需要停机.</p><br><p>4、具有Ubuntu和CentOS 的启动脚本</p><br><p>5、停止不稳定的进程（避免无限循环）</p><br><p>6、控制台检测</p><br><p>7、提供 HTTP API</p><br><p>8、远程控制和实时的接口API ( Nodejs 模块,允许和PM2进程管理器交互 )</p><br><p>9、简洁明了的可视化窗口和调试信息。</p><br></div><p>上面都是网上找的优点，在使用过程中我只有明显使用到1、2、3、6、9这几个而已。</p><p>1、负载均衡。你完全可以使用Node cluster建立自己的子线程，同时开启多个进程来监听同一个端口，分发http请求处理。但是都有pm2帮你做了你何必又自己做呢？所以对于node的Node cluster作为了解即可啦。</p><p>2、守护进程，上面已经说了离开了远端项目还是能正常使用。我们一般启动的时候，pm2会默认根据机器具有几核，智能的给你开启多核。除非你自己手动限制开启。pm2 start xxx.js -i 就能启动你需要的server服务，然后-i 指定多开数量,默认为自动根据机器配置开启。</p><p>3、0秒停机重载。这个是不是和负载均衡有点异曲同工？</p><h1 id="pm2配置"><a href="#pm2配置" class="headerlink" title="pm2配置"></a>pm2配置</h1><h3 id="生成脚本"><a href="#生成脚本" class="headerlink" title="生成脚本"></a>生成脚本</h3><p>就像webpack的webpack.config.js和npm包管理的package.json一样。<br>pm2的配置脚本也是需要的，我们可以在终端pm2 ecosystem</p><p>会在工程下面生成一个ecosystem.config.js。（当然你可以手动新建一个该文件）</p><h3 id="修改脚本"><a href="#修改脚本" class="headerlink" title="修改脚本"></a>修改脚本</h3><p>根据项目简简单单的编写一下脚本<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"apps"</span>: [&#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"my-app"</span>,</span><br><span class="line">        <span class="string">"max_memory_restart"</span>: <span class="string">"300M"</span>,</span><br><span class="line">        <span class="string">"script"</span>: <span class="string">"./build/main.js"</span>,</span><br><span class="line">        <span class="string">"out_file"</span>: <span class="string">"/home/efun/logs/my-app-logs/my-app-out.log"</span>,</span><br><span class="line">        <span class="string">"error_file"</span>: <span class="string">"/home/efun/logs/my-app-logs/my-app-error.log"</span>,</span><br><span class="line">        <span class="string">"merge_logs"</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="string">"instances"</span>: 2,</span><br><span class="line">        <span class="string">"exec_mode"</span>: <span class="string">"cluster"</span>,</span><br><span class="line">        <span class="string">"env"</span>: &#123;</span><br><span class="line">            <span class="string">"NODE_ENV"</span>: <span class="string">"development"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"env_production"</span>: &#123;</span><br><span class="line">            <span class="string">"NODE_ENV"</span>: <span class="string">"production"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当然，你要是想进行更为复杂的操作你可以企业看官网;<a href="http://pm2.keymetrics.io/docs/usage/quick-start/" target="_blank" rel="noopener">呐，地址都给你了</a></p><p>配置好了脚本怎么使用？</p><p>如果你不需要使用npm命令启动，你完全可以使用pm2的命令启动。后面跟你项目的入口js文件。<br>pm2 start xxx.js</p><h3 id="使用脚本启动项目"><a href="#使用脚本启动项目" class="headerlink" title="使用脚本启动项目"></a>使用脚本启动项目</h3><p>当然，启动nuxt（说白了,使用node作为前端服务器，都应该使用这种启动方法），结合package.json的script脚本进行操作。</p><p>下面是package.json可以作为参考</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">      <span class="string">"dev"</span>: <span class="string">"backpack dev"</span>,</span><br><span class="line">      <span class="string">"build"</span>: <span class="string">"nuxt build &amp;&amp; backpack build"</span>,</span><br><span class="line">      <span class="string">"start"</span>: <span class="string">"cross-env NODE_ENV=production node build/main.js"</span>,</span><br><span class="line">      <span class="string">"precommit"</span>: <span class="string">"npm run lint"</span>,</span><br><span class="line">      <span class="string">"lint"</span>: <span class="string">"eslint --ext .js,.vue --ignore-path .gitignore ."</span>,</span><br><span class="line">      <span class="string">"prod"</span>: <span class="string">"PORT=34004 pm2 start ecosystem.json --env production"</span>,</span><br><span class="line">      <span class="string">"pre-prod"</span>: <span class="string">"PORT=34104 pm2 start ecosystem-test.json --env production"</span>,</span><br><span class="line">      <span class="string">"pre-restart"</span>: <span class="string">"pm2 restart my-app"</span>,</span><br><span class="line">      <span class="string">"prod-restart"</span>: <span class="string">"pm2 restart my-app"</span>,</span><br><span class="line">      <span class="string">"pre-stop"</span>: <span class="string">"pm2 delete my-app"</span>,</span><br><span class="line">      <span class="string">"prod-stop"</span>: <span class="string">"pm2 delete my-app"</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure><p>启动预发布环境就执行 npm run pre-prod启动项目，执行的是ecosystem-test.json，通过PORT把端口传过去进行区分预发布和正式环境。<br>启动预正式环境就执行 npm run prod启动项目，执行的是ecosystem.json。</p><p>查看程序运行：<br>[efun@Nodejskr75 pf-kr-pre]$ pm2 list<br>┌──────────────────┬────┬─────────┬───────┬────────┬─────────┬────────┬─────┬───────────┬──────┬──────────┐<br>│ App name         │ id │ mode    │ pid   │ status │ restart │ uptime │ cpu │ mem       │ user │ watching │<br>├──────────────────┼────┼─────────┼───────┼────────┼─────────┼────────┼─────┼───────────┼──────┼──────────┤<br>│ my-app           │ 51 │ cluster │ 4859  │ online │ 6       │ 2h     │ 0%  │ 87.7 MB   │ efun │ disabled │<br>│ my-app           │ 52 │ cluster │ 4864  │ online │ 6       │ 2h     │ 0%  │ 98.3 MB   │ efun │ disabled │<br>└──────────────────┴────┴─────────┴───────┴────────┴─────────┴────────┴─────┴───────────┴──────┴──────────┘</p><p>停用运行的程序<br>pm2 stop my-app</p><p>[efun@Nodejskr75 pf-kr-pre]$ pm2 stop my-app<br>[PM2] Applying action stopProcessId on app <a href="ids: 51,52" target="_blank" rel="noopener">my-app</a><br>[PM2] <a href="51">pf-kq-pre</a> ✓<br>[PM2] <a href="52">pf-kq-pre</a> ✓<br>┌──────────────────┬────┬─────────┬───────┬─────────┬─────────┬────────┬─────┬───────────┬──────┬──────────┐<br>│ App name         │ id │ mode    │ pid   │ status  │ restart │ uptime │ cpu │ mem       │ user │ watching │<br>├──────────────────┼────┼─────────┼───────┼─────────┼─────────┼────────┼─────┼───────────┼──────┼──────────┤<br>│ my-app           │ 51 │ cluster │ 0     │ stopped │ 6       │ 0      │ 0%  │ 0 B       │ efun │ disabled │<br>│ my-app           │ 52 │ cluster │ 0     │ stopped │ 6       │ 0      │ 0%  │ 0 B       │ efun │ disabled │<br>└──────────────────┴────┴─────────┴───────┴─────── ─┴─────────┴────────┴─────┴───────────┴──────┴──────────┘</p><p>停用后想重启程序，可以使用pm2命令reload。 pm2 reload my-app<br>也可以使用npm命令 npm run pre-restart (实际上还是执行pm2 reload my-app)</p><p>stop并不能清理程序，也不会释放端口，而是要delete：</p><p>[azuo1228@Server Meanjs-MMM]$ pm2 delete my-app<br>[PM2] Applying action deleteProcessId on app <a href="ids: 0,1" target="_blank" rel="noopener">all</a><br>[PM2] <a href="1">server</a> ✓<br>[PM2] <a href="0">server</a> ✓<br>┌──────────┬────┬──────┬─────┬────────┬─────────┬────────┬─────┬─────┬──────────┐<br>│ App name │ id │ mode │ pid │ status │ restart │ uptime │ cpu │ mem │ watching │<br>└──────────┴────┴──────┴─────┴────────┴─────────┴────────┴─────┴─────┴──────────┘<br> Use <code>pm2 show &lt;id|name&gt;</code> to get more details about an app</p><p>好咯，说了一堆pm2。下面说说使用pm2部署遇到的几个坑点。</p><p>#坑一：<br>部署到线上，需要执行<code>npm run build</code>编译成静态文件（同时压缩js、css等） 。</p><p>或者按照文档说的执行 <code>nuxt build</code>,这样项目才读取的才是硬盘里的文件。这一点和使用vue-cli脚手架部署一样。</p><p>有次就是忘记执行了，导致访问页面路由一直在loading，但是就是不出来内容，或者出来个502.<br>这里最好就一起写在npm命令的脚本里，以免下次又漏了。</p><p>因为公司是使用jenkins进行自动化部署，所以我这个build是放在jenkins进行操作的。</p><p>所以在提交git后，使用compile命令进行编译，rsync进行同步，restart进行重启，stop进行停用，start进行启动。</p><p>因为并不是所有公司都使用jenkins发布，所以这里就不多说。不过jenkins真的好处多多，好用又方便。</p><p>#坑二：</p><p>一个域名被解析到一个静态服务器，上面有很多静态html等各种资源(域名根目录未被使用)。后来需要加一个平台上去，同时这个平台使用该域名(根目录映射平台首页)。</p><p>这个时候，就需要运维同事的配合了。在处理前端访问url的时候，先经过Nginx的应用层，然后Nginx先判断改url是否带有静态资源特征，也就是.js .css .jpg .png ….。根据不同的资源路径或者路由进行分发指向node服务器还是原有的静态服务器。</p><p>这里上个Nginx的过滤规则：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">location ~* ^.+.(jpg|jpeg|gif|css|png|js|ico|txt|srt|swf)$ &#123;</span><br><span class="line">    root /var/www/mywebsite/site/;</span><br><span class="line">    expires 30d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在nuxt部署后。</p><p>首页路由为：<a href="http://www.mywebsite.com" target="_blank" rel="noopener">www.mywebsite.com</a> ,页面依赖的其中一个js路径为<a href="https://www.mywebsite.com/_nuxt/manifest.e6cf8cf6462faca1a03e.js" target="_blank" rel="noopener">https://www.mywebsite.com/_nuxt/manifest.e6cf8cf6462faca1a03e.js</a></p><p>这个时候，页面上所有的js引用都是404</p><p>原因是因为运维同事的过滤规则导致页面读取js静态资源，跑到静态服务器上面找去了。当然找不到。因为这个js文件我们部署build的时候，是在node服务器上的。</p><p>这个时候需要在Nginx的过滤规则上加多权重更高的一个过滤。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location ~^/_nuxt/ &#123;</span><br><span class="line"><span class="built_in">alias</span> /mywebsite/.nuxt/dist/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上面是Nginx具有中间应用层的情况下的规则。那如果不需要应用层Nginx规则则为如下：</p><pre><code class="bash">location /_nuxt/ {    <span class="built_in">alias</span> /var/www/mywebsite/.nuxt/dist/;}location ~* ^.+.(jpg|jpeg|gif|css|png|js|ico|txt|srt|swf|woff|woff2)$ {    rewrite    ^/_nuxt(/.*) <span class="variable">$1</span> <span class="built_in">break</span>;    root /var/www/mywebsite/.nuxt/dist;    expires 30d;}</code></pre><p>这个在nuxt的issue地址有这个<a href="https://github.com/nuxt/nuxt.js/issues/2795" target="_blank" rel="noopener">提问</a></p><p>暂时说这么多，下次想到有补充再补充一下。</p><p>下一篇应该就是整理webpack的单页面和多页面的配置了。</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Vue中响应式检测数组、对象的属性变化（增加或者删除）</title>
      <link href="/2018/07/17/vue-watch-objeck/"/>
      <url>/2018/07/17/vue-watch-objeck/</url>
      <content type="html"><![CDATA[<p>Vue的官方文档说到： <a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">Vue 最独特的特性之一，是其非侵入性的响应式系统。</a> 数据模型data仅仅是普通的 JavaScript 对象。而当你修改它们时，视图会进行更新。</p><p>但是有时候发现修改了model层数据模型data的时候，view视图层却不能及时、有效的得到更新。往往这类的问题出现都是因为动态操作了数组或者对象字面量的属性导致。</p><p>这里会有几种情况例子，但是其实都是<code>同一个问题</code>。</p><a id="more"></a><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="一-：-Vue并不能检测已经创建的实例上动态添加新的根级响应式属性"><a href="#一-：-Vue并不能检测已经创建的实例上动态添加新的根级响应式属性" class="headerlink" title="一 ： Vue并不能检测已经创建的实例上动态添加新的根级响应式属性"></a>一 ： <code>Vue并不能检测已经创建的实例上动态添加新的根级响应式属性</code></h3><p>所谓的根级就是data下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  data:&#123;</span><br><span class="line">  a:1</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// `vm.a` 是响应的</span><br><span class="line"></span><br><span class="line">vm.b = 2</span><br><span class="line">// `vm.b` 是非响应的</span><br></pre></td></tr></table></figure><div class="tip"><br>   官方的解释是：受现代 JavaScript 的限制 (以及废弃 Object.observe)。由于 Vue 会在初始化实例时对属性执行 getter/setter 转化过程，所以属性必须在 data 对象上存在才能让 Vue 转换它，这样才能让它是响应的<br></div><h3 id="二-：-Vue并不能检测到已对象属性中属性的添加或者删除"><a href="#二-：-Vue并不能检测到已对象属性中属性的添加或者删除" class="headerlink" title="二 ： Vue并不能检测到已对象属性中属性的添加或者删除"></a>二 ： <code>Vue并不能检测到已对象属性中属性的添加或者删除</code></h3><p>在我们处理业务逻辑的时候，给data选项里的一个空数组或者空对象增加属性并赋值，然后我们页面是动态依赖这个对象或者数组的属性。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=<span class="string">"item,index in items"</span> v-on:click=<span class="string">"handle(index)"</span>&gt;</span><br><span class="line">     &lt;span&gt;&#123;&#123;item.name&#125;&#125; is :&lt;/span&gt;</span><br><span class="line">     &lt;span&gt;&#123;&#123;numbers[index]&#125;&#125;&lt;/span&gt;</span><br><span class="line"> &lt;/li&gt;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="title">data</span></span>()&#123;</span><br><span class="line">     <span class="built_in">return</span> &#123;</span><br><span class="line">         numbers: [],</span><br><span class="line">         items: [</span><br><span class="line">             &#123;name: <span class="string">'jjj'</span>&#125;,</span><br><span class="line">             &#123;name: <span class="string">'kkk'</span>&#125;,</span><br><span class="line">             &#123;name: <span class="string">'lll'</span>&#125;,</span><br><span class="line">         ]</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> methods: &#123;</span><br><span class="line">     handle: <span class="keyword">function</span> (index) &#123;</span><br><span class="line">         // WHY: 更新数据，view层未渲染，但通过console这个数组可以发现数据确实更新了</span><br><span class="line">         <span class="keyword">if</span> (typeof(this.numbers[index]) === <span class="string">"undefined"</span> ) &#123;</span><br><span class="line">             this.numbers[index] = 1;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             this.numbers[index]++;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>结果发现：点击之后数字并没有在view层更新</p><h3 id="三：-当你利用对象的索引直接设置一个项时"><a href="#三：-当你利用对象的索引直接设置一个项时" class="headerlink" title="三： 当你利用对象的索引直接设置一个项时"></a>三： <code>当你利用对象的索引直接设置一个项时</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;li v-for=<span class="string">"item,index in items"</span> v-on:click=<span class="string">"handle(index)"</span>&gt;</span><br><span class="line">     &lt;span&gt;&#123;&#123;item.name&#125;&#125; is :&lt;/span&gt;</span><br><span class="line">     &lt;span&gt;&#123;&#123;numbers[index]&#125;&#125;&lt;/span&gt;</span><br><span class="line"> &lt;/li&gt;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="title">data</span></span>()&#123;</span><br><span class="line">     <span class="built_in">return</span> &#123;</span><br><span class="line">         numbers: [</span><br><span class="line">             &#123;</span><br><span class="line">             name: <span class="string">"k"</span></span><br><span class="line">             &#125;,</span><br><span class="line">             &#123;</span><br><span class="line">             name: <span class="string">"kk"</span></span><br><span class="line">             &#125;,</span><br><span class="line">             &#123;</span><br><span class="line">             name: <span class="string">"kkk"</span></span><br><span class="line">             &#125;</span><br><span class="line">         ],</span><br><span class="line">         items: [</span><br><span class="line">             &#123;name: <span class="string">'jjj'</span>&#125;,</span><br><span class="line">             &#123;name: <span class="string">'kkk'</span>&#125;,</span><br><span class="line">             &#123;name: <span class="string">'lll'</span>&#125;,</span><br><span class="line">         ]</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> methods: &#123;</span><br><span class="line">     handle: <span class="keyword">function</span> (index) &#123;</span><br><span class="line">         this.numbers[_index].name = _index;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>结果发现：点击item并没有在view层更新index</p><h3 id="四：-当你修改数组的长度时"><a href="#四：-当你修改数组的长度时" class="headerlink" title="四：  当你修改数组的长度时"></a>四：  <code>当你修改数组的长度时</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  data: &#123;</span><br><span class="line">    items: [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">vm.items[1] = <span class="string">'x'</span> // 不是响应性的</span><br><span class="line">vm.items.length = 2 // 不是响应性的</span><br></pre></td></tr></table></figure><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>要解释上述问题，最好的方法就是了解一下Vue在render数据的时候，是如何实现数据的双向绑定的。</p><p>Vue实例的data选项，是一个普通的JavaScript对象。</p><p>Vue在render前，将会递归遍历data选项上所有的属性，并使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty</a>把这些属性全部转化为<code>setter/getter</code>。如果想要获取这个属性的内部值，Vue会内部调用getter进行取值，同理赋值的时候，Vue内部就会调用setter进行设值。</p><div class="tip"><br>    但是Object.defineProperty不支持IE8，所以Vue就不兼容IE8以及更低版本的浏览器了。<br></div><p>那么，到这里就可以解释到Vue是怎么进行数据的双向绑定了。</p><p>每个组件实例都有自己对应的watcher实例对象，它会在组件渲染的过程中把属性记录为依赖，当依赖项的setter被调用时（也就是data选项里的属性被修改操作，一般为赋值），会通知watcher重新计算。从而致使它关联的组件进行更新。</p><div class="tip"><br>    补充一点setter和getter的知识：<br>    访问器属性不包含数据值，他们包含一对getter函数和setter函数（这两个函数不是必须的）。在读取访问器属性时，会调用getter函数，这个函数负责返回有效的值；在写入访问器属性是，会调用setter函数并传入新值，这个函数负责决定如何处理数据。<br></div><p>也就是在渲染的过程中，<code>data作为页面的基础数据进行渲染。这个时候是首先是递归调用该对象属性的getter函数进行取值，然后getter函数的每一次调用都会通知watcher，告知属性将被调用（getter）并让watcher将之声明为依赖。如果属性被操作（setter进行设值）并发生变化，setter函数的每一次调用也会通知watcher对象，watcher对象收到通知就会重新渲染组件，以此来完成视图的更新，达到响应式。</code></p><p>那么我们回到问题，为什么我们有时候操作对象属性的时候为什么view视图层不能及时、有效的得到更新。</p><p>因为Vue在初始化实例的时候会先递归遍历并关联data选项里面以有的属性，执行了setter/getter转化过程，所以属性必须开始就在对象上，这样才能让Vue转化它。<br>至于后来对视图进行操作才给相应的空数组或对象进行增加属性操作的时候，Vue就不能检测到被操作为对象中属性的添加或者删除。所以也就达不到双向绑定了。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><h3 id="使用-Vue-set-object-key-value-方法将响应属性添加到嵌套的对象上。-还可以使用-vm-set-实例方法，这也是全局-Vue-set-方法的别名。"><a href="#使用-Vue-set-object-key-value-方法将响应属性添加到嵌套的对象上。-还可以使用-vm-set-实例方法，这也是全局-Vue-set-方法的别名。" class="headerlink" title="使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上。 还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名。"></a><code>使用 Vue.set(object, key, value) 方法将响应属性添加到嵌套的对象上。 还可以使用 vm.$set 实例方法，这也是全局 Vue.set 方法的别名。</code></h3><p>例如文章的例子一修改为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(vm.someObject, <span class="string">'b'</span>, 2) || this.<span class="variable">$set</span>(this.someObject,<span class="string">'b'</span>,2)</span><br></pre></td></tr></table></figure><p>例子二是为已有对象上添加一些属性，对此这里会分两种情况。</p><h3 id="情况一：操作数组，数组对固定的索引设值，使用-Vue-set-object-key-value"><a href="#情况一：操作数组，数组对固定的索引设值，使用-Vue-set-object-key-value" class="headerlink" title="情况一：操作数组，数组对固定的索引设值，使用 Vue.set(object, key, value)"></a><code>情况一：操作数组，数组对固定的索引设值，使用 Vue.set(object, key, value)</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    handle: <span class="keyword">function</span> (index) &#123;</span><br><span class="line">        // WHY: 更新数据，view层未渲染，但通过console这个数组可以发现数据确实更新了</span><br><span class="line">       <span class="keyword">if</span> (typeof(this.numbers[index]) === <span class="string">"undefined"</span> ) &#123;</span><br><span class="line">         this.<span class="variable">$set</span>(this.numbers, index, 1);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         this.<span class="variable">$set</span>(this.numbers, index, ++this.numbers[index]);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="情况二：操作数组，数组不针对固定的索引设值，可以使用push操作"><a href="#情况二：操作数组，数组不针对固定的索引设值，可以使用push操作" class="headerlink" title="情况二：操作数组，数组不针对固定的索引设值，可以使用push操作"></a><code>情况二：操作数组，数组不针对固定的索引设值，可以使用push操作</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    handle: <span class="keyword">function</span> (index) &#123;</span><br><span class="line">        this.numbers.push(index)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="操作数组或者操作对象字面量增加属性，使用-Object-assign-创建一个新的数组-对象，让它包含原对象的属性和新的属性："><a href="#操作数组或者操作对象字面量增加属性，使用-Object-assign-创建一个新的数组-对象，让它包含原对象的属性和新的属性：" class="headerlink" title="操作数组或者操作对象字面量增加属性，使用 Object.assign()创建一个新的数组/对象，让它包含原对象的属性和新的属性："></a><code>操作数组或者操作对象字面量增加属性，使用 Object.assign()创建一个新的数组/对象，让它包含原对象的属性和新的属性：</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">    handle: <span class="keyword">function</span> (index) &#123;</span><br><span class="line">       // 代替 this.<span class="variable">$set</span>(this.numbers, index, 1);</span><br><span class="line">        this.numbers = Object.assign([], this.numbers, [index])</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对于问题四，操作数组的长度。Vue-包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下："><a href="#对于问题四，操作数组的长度。Vue-包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下：" class="headerlink" title="对于问题四，操作数组的长度。Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下："></a><code>对于问题四，操作数组的长度。Vue 包含一组观察数组的变异方法，所以它们也将会触发视图更新。这些方法如下：</code></h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">push()</span><br><span class="line">pop()</span><br><span class="line"><span class="built_in">shift</span>()</span><br><span class="line">unshift()</span><br><span class="line">splice()</span><br><span class="line">sort()</span><br><span class="line">reverse()</span><br></pre></td></tr></table></figure><p>以上这些其实官方文档都有写明，只是在看文档的时候并不能在脑海里想象得到一些使用用例，导致就算看过这一块文档介绍但是遇到这一问题还是没能找到原因所在。</p><p><a href="https://cn.vuejs.org/v2/guide/list.html#注意事项" target="_blank" rel="noopener">关于操作数组的官方文档参考：列表渲染</a></p><p><a href="https://cn.vuejs.org/v2/guide/reactivity.html" target="_blank" rel="noopener">关于响应式的官方文档参考</a></p>]]></content>
      
      
    </entry>
    
  
  
</search>
